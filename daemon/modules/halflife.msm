# Metastats Listener Daemon - Half-Life Game Support Module
# ---------------------------------------------------------
# A statistical data logger for multiplayer games
# Copyright (c) 2004-2006, Nick Thomson.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

use strict;
use POSIX;
package halflife;

# void init ()
# This function is called when Metastats loads the module.
# Inside should be any initialisation code which the module
# needs to perform BEFORE any sockets etc are set up.
#
sub init
{
	shift;
	
	print "\t\t\t\t[ done ]\n";
	
	return 1;
}

# void parse (string server_id, gametype, data)
# 
# This function is called by Metastats when data is
# available for parsing. Metastats checks the sender's
# IP and port to see which module to send it to, and also
# finds out which MOD module our GAME module should pass
# pre-parsed code on to.
# ip, and port are self explainatory
# gametype is the name of the module to call for later
# mod-specific parsing.
#
sub parse
{
	shift;
	my ($db, $server, $line) = @_;
	my ($utime, $htime, $otime, $out);
	my $ext = $server->{Extension};
	
	$line =~ s/[\r\n\0]//g; # Remove Naughty Characters
	
	# Get timestamp, matches and removes "*L MM/DD/YYYY - HH:MM:SS: "
	#                                        $1 $2  $3    $4 $5 $6
	if ($line =~ s/^.*L (\d\d)\/(\d\d)\/(\d{4}) - (\d\d):(\d\d):(\d\d):\s*//) {
		my ($mo, $d, $yr, $h, $m, $s) = ($1, $2, $3, $4, $5, $6);
		if (!$main::conf{UseTimestamp}) {
			# Use System Time
			($s, $m, $h, $d, $mo, $yr) = localtime(time());
			$mo++;
			$yr += 1900;
		}
		$h  =~ s/^[0-9]{1}$/0$h/;
		$m  =~ s/^[0-9]{1}$/0$m/;
		$s  =~ s/^[0-9]{1}$/0$s/;
		$d  =~ s/^[0-9]{1}$/0$d/;
		$mo =~ s/^[0-9]{1}$/0$mo/;
		
		$utime = main::timegm($s, $m, $h, $d, ($mo)-1, ($yr)-1900);
		$htime = "$h:$m:$s $d/$mo/$yr";
		$otime = "L $mo/$d/$yr - $h:$m:$s:";
	} else {
		print "MALFORMED DATA: $line\n";
		return 0;
	}
	
	if ($server->{NumPlayers} < $main::conf{MinPlayers}) {
		print "IGNORED (Not MinPlayers): $line\n";
		return 0;
	}
	
	if ($line =~ /^\/\//) {
		# 000. // Comment
		# I am a comment, Ignore me.
	} elsif ($line =~ /^Server cvar/) {
		if ($line =~ /^Server cvars start/) {
			# 001.a Server cvars start
			$out = "CVARS: start";
		} elsif ($line =~ /^Server cvar \"(.*?)\" = \"(.*?)\"/) {
			# 001.b Server cvar "var = "value"
			$out = "CVAR: $1 = $2";
			$ext->cvarEvent($server, $utime, $1, $2);
		} elsif ($line =~ /^Server cvars end/) {
			# 001.c Server cvars end
			$out = "CVARS: end";
		}
	} elsif ($line =~ /^Log/) {
		if ($line =~ /^Log file started \(file \"(.*?)\"\) \(game \"(.*?)\"\) \(version \"(.*?)\/(.*?)\/(.*?)\"\)/) {
			# 002.a Log file started (file "name") (game "game") (version "protocol/release/build")
			$out = "LOG: started logging to $1 for game: $2";
			$out = "LOG: protocol: $3 / release: $4 / build: $5";
			$server->{LogFile} = $1;
# open IO
		} elsif ($line =~ /^Log file closed/) {
			# 002.b Log file closed
			$out = "LOG: closed";
			$server->{LogFile} = '';
# write line, close IO
		}
	} elsif ($line =~  /^(Loading|Started) map \"(.*?)\" (\(CRC \"(.*?)\"\))?/) {
		if ($1 eq 'Loading') {
			# 003.a Loading map "map"
			$out = "MAP: Loading $2";
		} elsif ($1 eq 'Started') {
			# 003.b Started map "map" (CRC "crc")
			$out = "MAP: Started $2 (CRC $4)";
		}
		$server->{Map} = $2;
# increment # of times map has been played, replace current db value
	} elsif ($line =~ /^(Bad Rcon|Rcon)\: \"rcon (\d+) \"(.*?)\" (.*)\" from \"(.*?)\"/) {
		# 004.a Rcon: "rcon challenge "pass" command" from "ip:port"
		$out = "Bad " if ($1 eq 'Bad Rcon');
		$out .= "Rcon: '$4' from $5 (pass: $3)";
		
		if ($1 eq 'Rcon') {
			if ($server->{Rcon} ne $3) {
				# if different, update db/$server
				my $query = "UPDATE
						$main::conf{DBPrefix}_core_servers
					SET
						server_rcon = '$3'
					WHERE
						server_id = $server->{ID}";
				main::dbQuery($db, $query);
				$out .= " -- Updated Rcon password from $server->{Rcon}";
				$server->{Rcon} = $3;
			}
		} elsif ($1 eq 'Bad Rcon') {
			# 004.b Bad Rcon: "rcon challenge "pass" command" from "ip:port"
			if ($server->{Rcon} eq $3) {
				# protect from bad rcon ban
				my $query = "UPDATE
						$main::conf{DBPrefix}_core_servers
					SET
						server_rcon = ''
					WHERE
						server_id = $server->{ID}";
				main::dbQuery($db, $query);
				$out .= " -- Protected Metastats from ban";
				$server->{Rcon} = '';
			}
		}
		
		if ($main::conf{RconRecord} == 1) {
			my $ip = (split(/\:/, $5))[0];
			my $query = "INSERT
				INTO
					$main::conf{DBPrefix}_halflife_events_rcon
				VALUES ('',
					$utime,
					$server->{ID},
					'$server->{Map}',
					'$1',
					'$ip',
					'$3',
					'$4')";
			main::dbQuery($db, ($query));
		}
	} elsif ($line =~ /^Server name is \"(.*)\"/) {
		# 005. Server name is "hostname"
		$out = "SERVER NAME: $1";
		my $query = "UPDATE
				$main::conf{DBPrefix}_core_servers
			SET
				server_name = '$1'
			WHERE
				server_id = $server->{ID}";
		$server->{Name} = $1;
	} elsif ($line =~ /^Server say \"(.*)\"/) {
		# 006. Server say "message"
		$out = "SERVER SAID: $1";
	} elsif ($line =~ /^World triggered \"(.*?)\"/) {
		# 062. World triggered "action"
		$out = "WORLD: triggered $1";
	} elsif ($line =~ /^Team/) {
		$line =~ s/^Team \"(.*?)\"\s+//;
		$ext->teamEvent($server, $utime, $1, $line);
		$out = "Handed to $ext";
	} elsif ($line =~ /^(\"|Player|Kick)/) {
		# 050-060, 066-069
		my %player = {};
		if ($1 eq 'Player') {
			$line =~ s/^Player \"(.*?)<(.*?)><(.*?)><(.*?)>\"\s*//;
			($player{Name}, $player{UID}, $player{SteamID}, $player{Team}) = ($1, $2, $3, $4);
		} elsif ($1 eq '"') {
			$line =~ s/^\"(.*?)<(.*?)><(.*?)><(.*?)>\"\s*//;
			($player{Name}, $player{UID}, $player{SteamID}, $player{Team}) = ($1, $2, $3, $4);
		} elsif ($1 eq 'Kick') {
			$line =~ s/^Kick: \"(.*?)<(.*?)><(.*?)><(.*?)>\"\s*//;
			($player{Name}, $player{UID}, $player{SteamID}, $player{Team}) = ($1, $2, $3, $4);
		}
		$ext->playerEvent($db, $server, $utime, \%player, $line);
		$out = "Handed to $ext";
	} else {
		$out = "UNRECOGNISED: $line";
	}
# access $writeThread for disc IO
# write "$otime $line\n"
	
	print "-> $out\n\n\n";
	
	return 1;
}

# array parseName (string data)
# Takes a HL log format name (name, sid, steamid, team)
# and parses it into individual variables
sub parseName
{
	my ($pData) = @_;
	my @rvals = ();
	$pData =~ /^(.*?)\<(\d*?)\>\<(.*?)\>\<(.*?)\>$/;
	#print "parseName: $1, $2, $3, $4\n";
	push @rvals, ($1, $2, $3, $4);
	return @rvals;
}

1;
