# Metastats Listener Daemon - Half-Life Game Support Module
# ---------------------------------------------------------
# A statistical data logger for multiplayer games
# Copyright (c) 2004-2006, Nick Thomson.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

package halflife;

# void init ()
# This function is called when Metastats loads the module.
# Inside should be any initialisation code which the module
# needs to perform BEFORE any sockets etc are set up.
#
sub init
{
	my $self = shift;
	
	print "    GAME: Loading halflife support..\t";
	%r = {};
	$r{Player} = '\"(.*?)\<(\d*?)\>\<(.*?)\>\<(.*?)\>\"';
	print "[ done ]\n";
	
	return 1;
}

# void parse (string server_id, gametype, data)
# This function is called by Metastats when data is
# available for parsing. Metastats checks the sender's
# IP and port to see which module to send it to, and also
# finds out which MOD module our GAME module should pass
# pre-parsed code on to.
# ip, and port are self explainatory
# gametype is the name of the module to call for later
# mod-specific parsing.
#
sub parse
{
	shift;
	my ($g_serverid, $g_type, $g_data) = @_;
	my ($utime, $htime, $otime);
	$g_data =~ s/[\r\n\0]//g; # Remove Naughty Characters
	
	# Get timestamp, matches and removes "*L MM/DD/YYYY - HH:MM:SS: "
	#                                        $1 $2  $3    $4 $5 $6
	if ($g_data =~ s/^.*L (\d\d)\/(\d\d)\/(\d{4}) - (\d\d):(\d\d):(\d\d):\s*//) {
		my ($mo, $d, $yr, $h, $m, $s) = ($1, $2, $3, $4, $5, $6);
		if (!$main::conf{UseTimestamp}) {
			# Use System Time
			($s, $m, $h, $d, $mo, $yr) = localtime(time());
			$mo++;
			$yr += 1900;
		}
		$h  =~ s/^[0-9]{1}$/0$h/;
		$m  =~ s/^[0-9]{1}$/0$m/;
		$s  =~ s/^[0-9]{1}$/0$s/;
		$d  =~ s/^[0-9]{1}$/0$d/;
		$mo =~ s/^[0-9]{1}$/0$mo/;
		$utime = main::timegm($s, $m, $h, $d, ($mo)-1, ($yr)-1900);
		$htime = "$h:$m:$s $d/$mo/$yr";
		$otime = "L $mo/$d/$yr - $h:$m:$s";
#		system("echo '$otime $g_data' >> $main::conf{LogClone}/$main::conf{LogFile}") if ($main::conf{LogClone} && $main::conf{LogFile});
	} else {
		print "--> MALFORMED DATA: $g_data\n";
	}
	
print "$htime: $g_data\n";
	if ($g_data =~ /^\"(.*?)\" (.*?) \"(.*?)\" (.*?) \"(.*?)\"/) {
print "Player: $g_data\n";
		# Matches "$player1" $action "$player2" $mod "$weapon" $prop
		
		my @parts = ($1, $2, $3, $4, $5, $6);
		
		my $sub_flag = 0;
		my $part = '';
		
		my $s_name = '';
		my $s_sid = '';
		my $s_steamid = '';
		my $s_team = '';
		
		my $o_name = '';
		my $o_sid = '';
		my $o_steamid = '';
		my $o_team = '';
		
		my @player1 = [];
		my @player2 = [];
		
		foreach $part (@parts) {
			if ($part =~ /\>$/) {
				@player1 = &parseName($part) if ($sub_flag == 0);
				@player2 = &parseName($part) if ($sub_flag == 1);
				$sub_flag++;
			}			
		}
		
		# [0] name, [2] ID, [3] team
		foreach $p_item (@player2) { push @player1, $p_item if @player2[2]; }
		# [4] name, [6] ID, [7] team.
		
		my $event_type = @parts[2];
		my $event_object = '';
		
		if (@parts[3] =~ /\>$/) {
			$event_object = @parts[5];
		} else {
			$event_object = @parts[3];
		}
		
		$main::mods[$g_type]->event($g_server_id, $utime, $event_type, $event_object, @player1);
	} elsif ($g_data =~ /^Team/) {
		if ($g_data =~ /^Team \"(.*?)\" triggered \"(.*?)\"/) {
			# 061. Team "team" triggered "action"
			print "-> TEAM: $1 triggered $2\n";
		} elsif ($g_data =~ /^Team \"(.*?)\" formed alliance with team \"(.*?)\"/) {
			# 064. Team "team" formed alliance with team "team"
			print "-> TEAM: $1 allied with $2\n";
		} elsif ($g_data =~ /^Team \"(.*?)\" scored \"(.*?)\" with \"(.*?)\" players/) {
			# 065. Team "team" scored "score" with "numplayers" players
			print "-> TEAM: $1 scored $2 with $3 players\n";
		}
	} elsif ($g_data =~ /^Player \$r{Player} scored \"(.*)\"/) {
		# 067. Player "name<uid><wonid><team>" scored "score"
		print "-> PLAYER: $1 scored $5\n";
	} elsif ($g_data =~ /^Rcon\: \"rcon (\d+) \"(.*?)\" (.*)\" from \"(.*?)\"/) {
		print "-> OK RCON: '$3' from $4 (pass: $2)\n";
	} elsif ($g_data =~ /^Bad Rcon\: \"rcon (\d+) \"(.*?)\" (.*)\" from \"(.*?)\"/){
		print "-> BADRCON: '$3' from $4 (pass: $2)\n";
	} elsif ($g_data =~ /^Kick\: \"(.*?)\" was kicked by \"(.*?)\" \(message \"([^"]*)\"\)/) {
		print "-> KICK: $1 was kicked by $2 (message '$3')\n\n";
	} elsif ($g_data =~ /^Server/) {
		if ($g_data =~ /^Server cvars start/) {
			print "-> CVARS: start\n";
		} elsif ($g_data =~ /^Server cvar \"(.*?)\" = \".*?\"/) {
			print "-> CVAR: $1 = $2\n";
		} elsif ($g_data =~ /^Server cvars end/) {
			print "-> CVARS: end\n";
		} elsif ($g_data =~ /^Server say \"(.*)\"/) {
			print "-> SERVER SAID: $1\n";
		} elsif ($g_data =~ /^Server name is \"(.*)\"/) {
			print "-> SERVER NAME: $1\n";
		}
	} elsif ($g_data =~ /^World (.*?) \"(.*?)\"/) {
		print "-> WORLD EVENT: $1 $2\n";
	} elsif ($g_data =~ /^Log/) {
		if ($g_data =~ /^Log file started \(file \"(.*?)\"\) \(game \"(.*?)\"\) \(version \"(.*?)\"\)/) {
			my $temp = $3;
			print "-> LOG: started logging to $1 for game: $2\n";
			$main::conf{LogFile} = $1 if ($main::conf{LogCloneDir}); #only good for one server, each server needs a logfile var
			$temp =~ /(.*?)\/(.*?)\/(.*?)/;
			print "-> LOG: protocol: $1 / release: $2 / build: $3\n";
		} elsif ($g_data =~ /^Log file closed/) {
			print "-> LOG: closed\n";
		} else {
			print "UNRECOGNISED LOG EVENT\n";
		}
	} elsif ($g_data =~ /^Loading map \"(.*?)\"/) {
		print "-> MAP: loading $1\n";
	} elsif ($g_data =~ /^Started map \"(.*?)\" \(CRC \"(.*?)\"\)/) {
		print "-> MAP: started $1 CRC: $2\n";
	} else {
		print "-> UNRECOGNISED: $g_data\n";
	}
	
	print "\n\n\n";
	
	return 1;
}

# array parseName (string data)
# Takes a HL log format name (name, sid, steamid, team)
# and parses it into individual variables
sub parseName
{
	my ($pData) = @_;
	my @rvals = ();
	$pData =~ /^(.*?)\<(\d*?)\>\<(.*?)\>\<(.*?)\>$/;
	#print "parseName: $1, $2, $3, $4\n";
	push @rvals, ($1, $2, $3, $4);
	return @rvals;
}

1;
